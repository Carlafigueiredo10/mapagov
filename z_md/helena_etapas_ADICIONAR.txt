# =============================================================================
# HELENA ETAPAS - Produto Principal
# =============================================================================

class HelenaEtapas(BaseHelena):
    """
    Produto Helena especializado em mapeamento completo de etapas.

    Responsabilidades:
    - Coletar etapas din√¢micas (n√£o fixo PMBOK)
    - Detalhar cada etapa: operador, sistemas, documentos, tempo, condicionais
    - Consolidar dados (sistemas, operadores, documentos)
    - Retornar dados estruturados para Helena POP
    """

    VERSION = "2.0.0"
    PRODUTO_NOME = "Helena Etapas"

    def inicializar_estado(self) -> Dict[str, Any]:
        """Estado inicial para mapeamento din√¢mico."""
        return {
            'etapas': [],
            'sistemas_consolidados': [],
            'operadores_consolidados': [],
            'documentos_consolidados': [],
            'concluido': False,
            'contexto_pop': {},
            '_etapa_sm': None
        }

    def inicializar_com_contexto(self, contexto: dict) -> dict:
        """
        Inicializa com contexto da Helena POP.

        Args:
            contexto: {
                'nome_processo': 'Compras',
                'area': 'TI',
                'nome_usuario': 'Roberto'
            }
        """
        estado = self.inicializar_estado()
        estado['contexto_pop'] = contexto

        nome_usuario = contexto.get('nome_usuario', '')
        nome_processo = contexto.get('nome_processo', 'este processo')

        resposta = f"""
üëã Ol√°{f' {nome_usuario}' if nome_usuario else ''}! Sou a **Helena Etapas**.

Vou te ajudar a mapear as etapas do processo **{nome_processo}** de forma completa e detalhada.

Para cada etapa, vou coletar:
‚úÖ Descri√ß√£o da etapa
‚úÖ Respons√°vel pela execu√ß√£o
‚úÖ Sistemas utilizados
‚úÖ Documentos requeridos e gerados
‚úÖ Tempo estimado
‚úÖ Condicionais (se houver decis√µes)

üéØ **Vamos come√ßar!**

üìã **Qual a PRIMEIRA etapa do processo?**

üí° _Descreva a primeira a√ß√£o que inicia o processo._

**Exemplos:**
- Funcion√°rio cria requisi√ß√£o no sistema SEI
- Cliente envia solicita√ß√£o por e-mail
- Documento √© recebido pelo protocolo
"""

        return self.criar_resposta(
            resposta=resposta,
            novo_estado=estado,
            progresso="0 etapas mapeadas"
        )

    def processar(self, mensagem: str, session_data: dict) -> dict:
        """Processa mensagem do usu√°rio."""
        self.validar_mensagem(mensagem)
        self.validar_session_data(session_data)

        msg_lower = mensagem.lower().strip()

        # Comandos especiais
        if 'resumo' in msg_lower or 'listar' in msg_lower:
            return self._gerar_resumo(session_data)

        if msg_lower in ['finalizar', 'concluir', 'terminar', 'n√£o', 'nao']:
            if session_data.get('_etapa_sm'):
                # Tem SM ativa, processar normalmente
                return self._processar_com_state_machine(session_data, mensagem)
            else:
                # Finalizar mapeamento
                return self._finalizar_mapeamento(session_data)

        # Processar com StateMachine
        return self._processar_com_state_machine(session_data, mensagem)

    def _processar_com_state_machine(self, estado: dict, mensagem: str) -> dict:
        """Processa usando EtapaStateMachine."""
        # Criar nova SM se n√£o existir
        if not estado.get('_etapa_sm'):
            numero_etapa = len(estado['etapas']) + 1
            contexto = estado.get('contexto_pop', {})

            sm = EtapaStateMachine(
                numero_etapa=numero_etapa,
                sistemas_disponiveis=contexto.get('sistemas_disponiveis', []),
                operadores_disponiveis=contexto.get('operadores_disponiveis', [])
            )

            estado['_etapa_sm'] = sm
            logger.info(f"Nova StateMachine criada para Etapa {numero_etapa}")

        # Processar mensagem
        sm = estado['_etapa_sm']
        resultado = sm.processar(mensagem)

        # Verificar se completou
        if sm.completa():
            etapa_dict = sm.obter_dict()
            estado['etapas'].append(etapa_dict)

            # Atualizar consolidados
            self._atualizar_consolidados(estado)

            # Destruir SM
            estado['_etapa_sm'] = None

            total_etapas = len(estado['etapas'])

            resposta = f"""
‚úÖ **Etapa {total_etapas} completa!**

üìä **Resumo r√°pido:**
- **Etapa:** {etapa_dict['descricao']}
- **Respons√°vel:** {etapa_dict['operador']}
- **Sistemas:** {', '.join(etapa_dict['sistemas']) if etapa_dict['sistemas'] else 'Nenhum'}
- **Tipo:** {'üîÄ Condicional' if etapa_dict.get('tipo') == 'condicional' else '‚û°Ô∏è Linear'}

üîÑ **H√° mais alguma etapa?**

Responda:
- Digite a **pr√≥xima etapa** para continuar
- Digite **"n√£o"** ou **"finalizar"** para concluir

_Comando: "resumo" para ver todas etapas_
"""

            return self.criar_resposta(
                resposta=resposta,
                novo_estado=estado,
                progresso=f"{total_etapas} etapa{'s' if total_etapas > 1 else ''} mapeada{'s' if total_etapas > 1 else ''}"
            )

        # Traduzir sinais da SM
        return self._traduzir_sinal_sm(estado, resultado)

    def _traduzir_sinal_sm(self, estado: dict, sinal: dict) -> dict:
        """Traduz sinais da StateMachine para respostas."""
        sm = estado['_etapa_sm']

        if 'erro' in sinal:
            return self.criar_resposta(
                resposta=f"‚ö†Ô∏è {sinal['erro']}",
                novo_estado=estado
            )

        # Pergunta: Operador
        if sinal.get('proximo') == 'OPERADOR':
            return self.criar_resposta(
                resposta="üë§ **Quem EXECUTA esta etapa?**\n\nüí° _Informe o cargo, fun√ß√£o ou pessoa respons√°vel._\n\n**Exemplos:** Funcion√°rio, Gestor, Analista de RH",
                novo_estado=estado
            )

        # Pergunta: Sistemas
        elif sinal.get('pergunta') == 'sistemas':
            return self.criar_resposta(
                resposta="üíª **Quais SISTEMAS s√£o utilizados nesta etapa?**\n\nüí° _Sistemas que o respons√°vel usa para executar._\n\n**Exemplos:** SEI, SIAFI, SIGA, Sigepe\n\n_Digite separados por v√≠rgula, ou 'nenhum'_",
                novo_estado=estado
            )

        # Pergunta: Docs Requeridos
        elif sinal.get('pergunta') == 'docs_requeridos':
            return self.criar_resposta(
                resposta="üìÑ **Quais DOCUMENTOS s√£o ANALISADOS/REQUERIDOS?**\n\nüí° _Documentos recebidos, lidos ou analisados._\n\n**Exemplos:** CPF, RG, Requisi√ß√£o, Despacho\n\n_Digite separados por v√≠rgula, ou 'nenhum'_",
                novo_estado=estado
            )

        # Pergunta: Docs Gerados
        elif sinal.get('pergunta') == 'docs_gerados':
            return self.criar_resposta(
                resposta="üì§ **Quais DOCUMENTOS s√£o PRODUZIDOS/GERADOS?**\n\nüí° _Documentos criados, emitidos ou gerados._\n\n**Exemplos:** Despacho, Parecer, Of√≠cio, Relat√≥rio\n\n_Digite separados por v√≠rgula, ou 'nenhum'_",
                novo_estado=estado
            )

        # Pergunta: Tempo
        elif sinal.get('pergunta') == 'tempo_estimado':
            return self.criar_resposta(
                resposta="‚è±Ô∏è **Qual o TEMPO ESTIMADO?**\n\nüí° _Tempo m√©dio para concluir._\n\n**Exemplos:** 15 minutos, 2 horas, 1 dia √∫til, Imediato\n\n_Digite o tempo ou 'pular'_",
                novo_estado=estado
            )

        # Pergunta: Tem Condicionais
        elif sinal.get('pergunta') == 'tem_condicionais':
            return self.criar_resposta(
                resposta="üîÄ **Esta etapa possui DECIS√ïES ou CONDICIONAIS?**\n\nüí° _H√° diferentes caminhos dependendo de uma condi√ß√£o?_\n\n**SIM:** Se aprovado ‚Üí etapa X, sen√£o ‚Üí etapa Y\n**N√ÉO:** Etapa sempre segue o mesmo caminho\n\n_Responda: **sim** ou **n√£o**_",
                novo_estado=estado
            )

        # Pergunta: Tipo Condicional
        elif sinal.get('pergunta') == 'tipo_condicional':
            return self.criar_resposta(
                resposta="üîÄ **Quantos cen√°rios existem?**\n\n1. **Bin√°rio** (2 cen√°rios) - Ex: Aprovado/Recusado\n2. **M√∫ltiplos** (3+) - Ex: Completo/Incompleto/Inv√°lido\n\n_Digite: **bin√°rio** ou **m√∫ltiplos**_",
                novo_estado=estado
            )

        # Pergunta: Antes Decis√£o
        elif sinal.get('pergunta') == 'antes_decisao':
            return self.criar_resposta(
                resposta="‚öôÔ∏è **O que √© feito ANTES da decis√£o?**\n\nüí° _A√ß√£o antes de tomar a decis√£o._\n\n**Exemplos:**\n- Analisar conformidade documental\n- Verificar dados no sistema\n- Avaliar crit√©rios t√©cnicos",
                novo_estado=estado
            )

        # Pergunta: Cen√°rios
        elif sinal.get('pergunta') == 'cenarios_descricoes':
            tipo = sm.tipo_condicional
            num = 2 if tipo == 'binario' else 3
            exemplo = '{"cenarios": [{"descricao": "Documenta√ß√£o completa"}, {"descricao": "Documenta√ß√£o incompleta"}]}'

            return self.criar_resposta(
                resposta=f"üìã **Descreva os {num} cen√°rios**\n\n**Formato JSON:**\n```json\n{exemplo}\n```",
                novo_estado=estado
            )

        # Pergunta: Subetapas
        elif sinal.get('pergunta') == 'subetapas':
            cenario = sinal.get('cenario_descricao', '')
            return self.criar_resposta(
                resposta=f"üìå **Cen√°rio: {cenario}**\n\nQuais as SUBETAPAS?\n\nüí° _Uma por linha, ou 'pular'_\n\n**Exemplo:**\n```\nNotificar solicitante\nArquivar processo\nRegistrar no sistema\n```",
                novo_estado=estado
            )

        # Pergunta: Detalhes
        elif sinal.get('pergunta') == 'detalhes':
            return self.criar_resposta(
                resposta="üìù **Quer adicionar DETALHES desta etapa?**\n\nüí° _Pequenas a√ß√µes dentro da etapa principal._\n\n**Exemplos:** Verificar campo X, Validar assinatura\n\n_Digite um detalhe ou 'n√£o'_",
                novo_estado=estado
            )

        # Mais detalhes
        elif sinal.get('pergunta') == 'mais_detalhes':
            detalhe = sinal.get('detalhe_adicionado', '')
            return self.criar_resposta(
                resposta=f"‚úÖ Detalhe adicionado: _{detalhe}_\n\nH√° mais? (Digite o pr√≥ximo ou 'n√£o')",
                novo_estado=estado
            )

        # Fallback
        return self.criar_resposta(
            resposta="Processando...",
            novo_estado=estado
        )

    def _atualizar_consolidados(self, estado: dict):
        """Atualiza listas consolidadas."""
        sistemas = set()
        operadores = set()
        documentos = set()

        for etapa in estado['etapas']:
            if etapa.get('sistemas'):
                sistemas.update(etapa['sistemas'])
            if etapa.get('operador'):
                operadores.add(etapa['operador'])
            if etapa.get('docs_requeridos'):
                documentos.update(etapa['docs_requeridos'])
            if etapa.get('docs_gerados'):
                documentos.update(etapa['docs_gerados'])

        estado['sistemas_consolidados'] = sorted(list(sistemas))
        estado['operadores_consolidados'] = sorted(list(operadores))
        estado['documentos_consolidados'] = sorted(list(documentos))

    def _finalizar_mapeamento(self, estado: dict) -> dict:
        """Finaliza e retorna para Helena POP."""
        if not estado['etapas']:
            return self.criar_resposta(
                resposta="‚ö†Ô∏è Nenhuma etapa foi mapeada. Descreva a primeira etapa.",
                novo_estado=estado
            )

        estado['concluido'] = True
        total = len(estado['etapas'])

        resposta = f"""
üéâ **Mapeamento conclu√≠do!**

üìä **Resumo:**
- ‚úÖ **{total} etapa{'s' if total > 1 else ''}** mapeada{'s' if total > 1 else ''}
- üíª **{len(estado['sistemas_consolidados'])} sistema{'s' if len(estado['sistemas_consolidados']) != 1 else ''}**
- üë• **{len(estado['operadores_consolidados'])} operador{'es' if len(estado['operadores_consolidados']) != 1 else ''}**
- üìÑ **{len(estado['documentos_consolidados'])} tipo{'s' if len(estado['documentos_consolidados']) != 1 else ''} de documento{'s' if len(estado['documentos_consolidados']) != 1 else ''}**

‚úÖ **Dados salvos! Retornando para Helena POP...**
"""

        # Retorna dados para Helena POP
        if estado.get('contexto_pop'):
            return self.criar_resposta(
                resposta=resposta,
                novo_estado=estado,
                progresso=f"{total} etapas conclu√≠das",
                retornar_para='pop',
                dados={
                    'etapas': estado['etapas'],
                    'sistemas_consolidados': estado['sistemas_consolidados'],
                    'operadores_consolidados': estado['operadores_consolidados'],
                    'documentos_consolidados': estado['documentos_consolidados']
                }
            )
        else:
            return self.criar_resposta(
                resposta=resposta,
                novo_estado=estado,
                progresso=f"{total} etapas conclu√≠das"
            )

    def _gerar_resumo(self, estado: dict) -> dict:
        """Gera resumo completo."""
        if not estado['etapas']:
            return self.criar_resposta(
                resposta="‚ö†Ô∏è Nenhuma etapa mapeada ainda.",
                novo_estado=estado
            )

        total = len(estado['etapas'])
        resposta = f"üìã **Resumo do Mapeamento - {total} Etapa{'s' if total > 1 else ''}**\n\n"

        for etapa in estado['etapas']:
            num = etapa['numero']
            desc = etapa['descricao']
            op = etapa['operador']
            tipo = 'üîÄ Condicional' if etapa.get('tipo') == 'condicional' else '‚û°Ô∏è Linear'

            resposta += f"**{num}. {desc}**\n   üë§ {op}\n"

            if etapa.get('sistemas'):
                resposta += f"   üíª {', '.join(etapa['sistemas'])}\n"
            if etapa.get('docs_requeridos'):
                resposta += f"   üì• Requer: {', '.join(etapa['docs_requeridos'])}\n"
            if etapa.get('docs_gerados'):
                resposta += f"   üì§ Gera: {', '.join(etapa['docs_gerados'])}\n"
            if etapa.get('tempo_estimado'):
                resposta += f"   ‚è±Ô∏è  {etapa['tempo_estimado']}\n"

            resposta += f"   {tipo}\n\n"

        resposta += f"""
**Consolidado:**
- üíª Sistemas: {', '.join(estado['sistemas_consolidados']) if estado['sistemas_consolidados'] else 'Nenhum'}
- üë• Operadores: {', '.join(estado['operadores_consolidados'])}
- üìÑ Documentos: {len(estado['documentos_consolidados'])} tipos

**Comando:** digite **finalizar** para concluir
"""

        return self.criar_resposta(
            resposta=resposta,
            novo_estado=estado,
            progresso=f"{total} etapas mapeadas"
        )

    def receber_dados(self, produto: str, dados: dict) -> dict:
        """Helena Etapas n√£o recebe dados de outros produtos."""
        return self.criar_resposta(
            resposta="Helena Etapas n√£o recebe dados de outros produtos.",
            novo_estado=self.inicializar_estado()
        )
